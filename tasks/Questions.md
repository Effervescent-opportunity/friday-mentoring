# Вопросы с ответами по заданиям и исправлениям

## Третье задание

1. Можно ли как-то протестировать само соединение через TLS, что сертификат работает и тд? И нужно ли в рамках задания?
> Можно, например: https://github.com/robinhowlett/everything-ssl (см. readme + src/test).
> В рамках задачи это не требуется, т.к. работа Spring Boot уже проверена до нас, см. https://github.com/spring-projects/spring-boot/tree/3.1.x/spring-boot-project/spring-boot/src/test/java/org/springframework/boot/web/server SslTests.java
2. Сервис защищен @PreAuthorize, а не @Secured и @PreFilter
> Плюс ещё есть @RolesAllowed. Но ни @RolesAllowed ни @Secured не позволят явным образом указать имя пользователя, только роль.
SpEL расширяет возможности и позволяет указать root явно, поэтому использование @PreAuthorize единственно правильно.
3. Добавлен PKCS12 keystore, команды для генерации ниже. Правда ощущение, что при запуске берется не из него
> Сертификат однозначно правильный и подхватывается именно он. По пути configured from нет такого файла (см. скрин). Похоже на баг в спринге, но подробнее сказать пока не могу.
> Здесь можно было бы сказать, что сертификат сгенерирован без Subject Alternative Name (IP, DNS), но во-первых, для localhost это избыточно, а во-вторых -- любой уважающий себя удостоверяющий центр даёт инструкцию по выпуску CSR, в которой это описано. Реализацию считаю корректной.
4. Для logout надо было использовать SecurityContextLogoutHandler
> К задаче есть два подхода: а) делать свои endpointы явно или б) целиком полагаться на фичи HttpSecurity. И тот и другой имеет право быть. SecurityContextLogoutHandler может дать преимущества в следующей задаче (а может и не дать). В общем, вопрос дискуссионный, т.к. оба варианта работают и явных недостатков первого подхода я не вижу.
5. Удалена аннотация @EnableWebSecurity, потому что работает и без нее (почему?)
> https://stackoverflow.com/questions/44671457
> If you are using Spring Boot, autoconfiguration classes (See https://github.com/spring-projects/spring-boot/tree/main/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/security) will autoconfigure security beans for you. There is no need for @EnableWebSecurity.

## Второе задание

1. OAUTH не нужен, так как его ему нужно внешнее апи + его главная фича - возможность авторизовываться в нескольких местах, мне не надо
> Совершенно верно. При рассмотрении OAuth важно понять идею, которая касается передачи всех clear-text credentials [RFC 6749 Section 3.2. Token Endpoint](https://www.rfc-editor.org/rfc/rfc6749#section-3.2) - сервер обязан использовать TLS.
2. Для AuthenticationEntryPoint выставлен HTTP код 404
> Хорошая идея, но в большинстве проектов не реализуется из-за требований DevOps к своему мониторингу.
> Если всё же возвращать 404 вместо 403, разбор попыток неавторизованного доступа усложнится, а чтобы не усложнять - для мониторинга нужно указывать конкретные имена endpointов, что в какой-то степени привязывает инфраструктуру к коду, но не является проблемой.
3. Ситуация "я могу 3 раза залогиниться, получить 3 разных JSESSIONID, разлогиниться из одного, и другие останутся рабочими"
> Если вкратце, вот поэтому: https://github.com/apache/tomcat/blob/main/java/org/apache/catalina/connector/Request.java#L2650
> Выход происходит из конкретной HTTP-сессии, JSESSIONID её уникально идентифицирует.
Это нормальное ожидаемое поведение для stateful аутентификации. Если требуется другое поведение, будут нюансы, см. [Properly Clearing an Authentication](https://docs.spring.io/spring-security/reference/servlet/authentication/session-management.html#properly-clearing-authentication) и далее по ссылкам.
4. Что такое возможность rememberMe
> Это возможность запоминать пользователя даже если JSESSIONID протухнет.
Подробности в [Remember-Me Authentication](https://docs.spring.io/spring-security/reference/servlet/authentication/rememberme.html).
5. Почему везде рекомендуют выключить csrf
> Не везде :) Spring рекомендует отключать на Remember-Me [When to use CSRF protection](https://docs.spring.io/spring-security/reference/features/exploits/csrf.html#csrf-when) и [No CSRF protection on remember-me authentication](https://github.com/spring-projects/spring-security/issues/3711), для остального REST API есть нюансы [Should I use CSRF protection on Rest API endpoints?](https://security.stackexchange.com/questions/166724/).
> В нашем конкретном случае CSRF можно смело отключить, т.к. браузерного взаимодействия (и вектора атаки) нет. К слову, при браузерном взаимодействии защита CSRF для POST, PUT, PATCH и DELETE используется парно с CORS, но это - отдельная большая тема в духе middle++, мы её не рассматриваем совсем.
6. Как exceptionHandling в конфиге соотносится с уже написанным мной ClockExceptionHandler
> Оба про исключения - в принципе, это всё, что у них общего. Суть:
> - ClockExceptionHandler обрабатывает ошибки всего, что вызывают методы REST контроллера. Он про то, как превращать ошибки прикладной логики в ответ REST API.
> - exceptionHandling - про HttpSecurity. Срабатывает "до" прикладной логики и отвечает за ошибки безопасности (до самого REST контроллера запрос может даже не дойти и срезаться на AuthorizationFilter).

## Первое задание

 1. Достаточно ли текущего времени сервера, можно ли ему доверять, или же необходимо реализовать синхронизацию с чем-то доверенным?
>можем; если предположить, что мы не доверяем времени сервера, в коде приложения разработчику придётся делать много дополнительных вещей, которые выходят за рамки чисто прикладного программирования. Поэтому считаем, что времени сервера можно доверять, а синхронизация системных часов по NTP — задача поддержки инфраструктуры, а не разработческая.\
Реализовать дополнительную синхронизацию имеет смысл, если мы занимаемся генерацией, подписанием или проверкой электронной цифровой подписи. Это стандарт, которому приложение обязано следовать, иначе оно не пройдёт сертификацию (Приказ ФСБ РФ от 4 декабря 2020 г. N 555). У нас в задаче такого нет.
 2. Зачем в контроллере объявление переменной var nowInTimezone и потом передача ее в конструктор? Можно же сразу return new CurrentTimeResponse(clockService.getNowInUtc())
>Сугубо дело вкуса, но если часто и помногу использовать вложенные конструкции, это не упрощает читаемость кода, а отладку — так и вообще усложняет, потому что для вычисления значения переменной нужно или становиться внутрь конструктора, что достаточно далеко от места вызова, или же вычислять значение лапками, что минус пять секунд и немного потеря контекста в голове. Если таких случаев по коду много, разница удобства очень заметна.
 3. Точно ли хороший стиль объявлять record прямо внутри Контроллера, а не в отдельном классе? Если да, то почему?
>Стиль неплохой, тем более если альтернативы только две "выносить" или "не выносить". Во-первых, record компактен, вынос в маленький файл не увеличивает удобство, поэтому не выносим. Во-вторых, прыжки по файлам лишний раз размывают внимание, а пользы не приносят, поэтому опять же не выносим. В-третьих, объект локально используется в пределах контроллера и за его границы не протекает. Поэтому — не выносим. Итого — совсем нет причин выносить в нашем конкретном случае.
 4. Про вот это:     // !!! Очень изящная реализация теста через ISO DateTimeFormatter, она позволяет не заморачиваться с хаками наподобие isAfter/isBefore для времени, но мысль не была доведена до конца :(  Как можно довести ее до конца? Насколько я понимаю, всякие наносекунды совпадать не будут при получении now() в сервисе и в тесте
>В предложенной реализации идея собственно и доведена до конца: мы знаем точный ответ сервиса и проверяем, что ответ контроллера в точности совпадает с тем, что вернул сервис, т.е.: а) контроллер не модифицирует данные сервиса и б) выполняет преобразование в корректный формат.
 5. Вы в тесте написали var tz = "Asia/Paris"; вместо String ianaTimezone = "Europe/Paris";. Это просто по привычке или же лучше писать var вместо явного объявления типа? Почему?
>Мне персонально нравится variable type inference, потому что код выглядит максимально компактно. Любая среда разработки в 2023 году уже подсвечивает тип — на случай, если он зачем-то понадобится. Лучше/хуже — субъективно, вопрос скорее проектных соглашений, если это правило явно закреплено, и личных духовных предпочтений, если не закреплено. Главное — соблюдать тотальное единообразие в пределах одного репозитория, т.е. либо всегда используем var (там, где выведение типа возможно) либо всегда не используем.
