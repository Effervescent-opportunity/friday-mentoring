# Вопросы с ответами по заданиям и исправлениям

## Пятое задание. Реализация

__По поводу реализации сервиса__

Retry Count не имеет большой пользы и даже вредно, потому что удаляет события, которые не отправлены.
В логике AuthEventService#processEvent нужно поступать с точностью до наоборот - удалять уже отправленные события.

__Касаемо работы с ORM и БД в частности__

1. На всякий случай замечу, что @Column(nullable = false) без автоматического создания схемы (spring.jpa.hibernate.ddl-auto=...) не имеет эффекта.
   Другими словами, Hibernate не запрещает вставку null значений, а ошибка возвращается со стороны БД - при условии, если на DDL используется not null (в текущей реализации так и есть).
   Используемый подход может применяться в целях документирования кода, чтобы не приходилось каждый раз лезть в БД или скрипты миграции (что ещё хуже) для того, чтобы выяснить nullабельность.

2. Подход с initdb.sql плохо масштабируется, это станет видно на второй же доработке, связанной с БД.
   Другими словами, лучше сразу использовать миграции (в примере использовался flyway для разнообразия).

3. Зависимость на io.hypersistence:hypersistence-utils-hibernate-62 явно лишняя.
   Насколько я понимаю, она используется ради поддержки JSON. Здесь сразу несколько моментов:

- в Hibernate 6 JSON поддерживается коробочно, см. [XML and JSON mapping](https://in.relation.to/2023/02/13/hibernate-orm-62-composite-aggregates/). Нужна будет доп. кастомизация из трёх строк, см.
  [#33870](https://github.com/spring-projects/spring-boot/issues/33870), но это явно не тянет на причину использовать аж целую библиотеку.
- на уровне DDL вместо json использовать [jsonb](https://www.postgresql.org/docs/current/datatype-json.html) из-за эффективности и чуть более богатых возможностей.
- есть два подхода: первый - всегда использовать jsonb. Второй - каждый раз выбирать между json и jsonb. Предпочитаю не выбирать, потому что json просто проигрывает по каждому пункту :)

4. Т.к. ключ генерируется самим Hibernate, в DDL можно и нужно использовать id uuid без значения по умолчанию.

5. type - хоть и non-reserved для PostgreSQL, но имеет специальное значение в некоторых контекстах. Рекомендую использовать другое название колонки чисто ради разграничения контекстов в голове разработчика.

## Пятое задание

1. Вопрос: есть ли best practice по поводу такой ситуации? Есть сервис А, вызывающий void-метод сервиса В. Сервис В может либо отработать как надо, либо что-то может пойти не так. И в сервисе А нужно об этом знать. Соответственно есть варианты возвращать true/false из сервиса В или же кидать исключение оттуда. Лично мне приятнее возвращать true/false, но много где на работе видела вариант с исключением (и обоснованием "так надо", что не отвечало на мой вопрос).
> true/false:
>1. не отражает семантику void;
>2. при неудачном именовании может путать (true - всё хорошо или всё плохо?);
>3. не даёт информации для диагностики.
>
>Но:
>1. если следовать вымышленному соответствию не нужно;
>2. именование понятно и true глобально по всему проекту означает успешный вызов;
>3. ошибки легко и просто разбираются по логам отдающей системы и есть механизм корреляции запросов сервиса А и ответа сервиса B...
>
>то можно обойтись true/false и это будет хорошо. При одновременном соблюдении трёх условий.

1.1. 2 - а как же java doc для этого?)
> 2 - если true и false используется в проекте произвольно и взаимозаменяемо, то эта проблема не решается через javadoc

2. Обоснование с точки зрения надежности из changelog.md
> 1. Может отказать БД (критична возможность записи), но поддерживается вариант развёртывания в failover конфигурации, в т.ч. георезервированной, что резко снижает такой риск. Плюс Spring Boot поддерживает прозрачное переключение БД со стороны jdbc-драйвера, следовательно, PG подходит.
> 2. Может отказать Kafka, это перестаёт быть страшным, т.к. сохранность событий гарантирована со стороны БД, а переотправка гарантирована со стороны приложения. Это же касается и случая переполнения очереди п.5 - kafka скажет что-то в духе ERROR Error while appending records to whatever in dir /var/lib/kafka/data-0/kafka-log0 (kafka.server.LogDirFailureChannel) [ReplicaFetcherThread-0-1] java.io.IOException: No space left on device и не пришлёт подтверждение записи. Приложение попытается сделать retry настроенное количество раз, не возымеет успеха и бросит свои попытки.
> 
> Уточнения по пунктам "Обоснование с точки зрения надежности":
> 3. может. Вероятность падения по нагрузке будет кратко посчитана в следующих сериях :)
> 4. верно, см. случай acks=1;
> 6. проблема немного другого класса, но хорошо, что она рассматривается.

3. Варианты развертывания тоже нужно уметь делать самостоятельно?
> если есть желание уйти в devops, то да;

4. По поводу retry настроенного количества раз - я думала завязаться только на время, что event'ы "протухают" через сутки и перестают пытаться отправиться. И отдельно метод контроллера с переотправкой более старых. Тут, конечно, от бизнес смысла и количества данных зависит, вот такой вариант мне показался наиболее логичным. Видимо потому что бизнес смысл не до конца прозрачен для меня :)
Ну и считать ретраем попытку отправки, когда Кафка недоступна, мне кажется перебором - я могу запустить приложение без Кафки в принципе, ретраи за минуту все уйдут в 0
> протухание - это защита от переполнения диска, а в случае именно с postgresql даст интересный эффект, потому что delete внезапно не приводит к освобождению места на диске.
Т.к. требований нет, изобретать обработку граничных случаев именно на этом этапе считаю опасным.

## Четвертое задание

1. Именование mentoring.auth.events.topic я бы делал в виде siem.events.topic (system.kind.topic).

2. В KafkaTest есть лишние тесты плюс ошибка компиляции.

3. Thread.sleep() не нужен, т.к. KafkaTestUtils корректно обрабатывает таймауты и ожидания, см.
   org.springframework.kafka.test.utils.KafkaTestUtils#getRecords:332

`do {
// ...
}
while (count < minRecords && remaining > 0);`

4. Использование mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); по рекомендации https://docs.spring.io/spring-kafka/reference/html/#tip-json 
всё же приводит к тому, что дата отправляется хоть и в приятном строковом виде, но из-за LocalDateTime — без таймзоны (!) 
 в виде "time":"2023-08-04T23:26:43.098285293", а реализация тестов эту проблему скрывает (!!) из-за AuthEventDtoDeserializer — мы
не видим в отладчике то, что ходит "по кабелю", т.е. реальную json-строку.

В некоторых видах интеграций отсутствие таймзоны может классифицироваться как грубая ошибка системного анализа (будем честны, ошибаются все, но это всплывает на первом же тестировании).

Что предлагается:

- использовать Instant, тогда датавремя будет представлено в виде "time":"2023-08-04T20:26:43.098285293Z" или OffsetDateTime, получим "time":"2023-08-04T23:26:43.098285293+03:00";
- удалить AuthEventDtoDeserializer и для checkAuthEventDto использовать ObjectMapper в духе

`try {
AuthEventDto authEventDto = objectMapper.readValue(String.valueOf(valueFromKafka), AuthEventDto.class);
// ...
} catch (JsonProcessingException e) {
Assertions.fail(e);
}`

p.s. чтобы не писать ужас String.valueOf(valueFromKafka), нужно использовать Consumer<String, String> consumer;  со всеми вытекающими —
ConsumerRecord<String, String> singleRecord - new DefaultKafkaConsumerFactory<String, String>(consumerProps).createConsumer(); и т.п.

5. Обычно выбирается один из двух подходов:
   1. "якобы модульный", когда проверяется, что вызывается метод отправки из какого-то "нашего" интерфейса (как именно реализован 
   интерфейс и отправляется ли что-то именно в кафку — такому тесту не интересно);
   2. "интеграционный" - проверяется, что сообщение дошло в получателя (как именно реализована отправка и доставка — такому тесту не интересно).
   
Смешивать оба способа не рекомендую, т.к. это противоречит каноническим подходам к тестированию и вдобавок принуждает разработчика ставить перед
собой (и, о невероятный ужас, пытаться решить) крайне странные задачи. В рамках одного класса — однозначно не рекомендую. 
В рамках проекта обычно делают разделение на "модульные" и "интеграционные" тесты (деление очень условно) и интеграционные тесты 
перекрывают несколько модульных, таким образом, тогда ситуация имеет право быть. Интеграционный тест, который проверяет то же, что и другой интеграционный тест, не оправдан.

6.  А интеграционный тест, который проверят то же, что и несколько модульных тестов, оправдан ли? Вернее наоборот, модульные, которые проверяют то, что есть в интеграционном?
> Оправданы, только если модульные тесты проверяют больше вариаций и деталей, чем интеграционные. Обычно так и есть, потому что проверять хитрые детали реализации 
> аж через интеграционный тест — слишком роскошно и с точки зрения скорости работы и с точки зрения трудоёмкости написания.

## Третье задание

1. Можно ли как-то протестировать само соединение через TLS, что сертификат работает и тд? И нужно ли в рамках задания?
> Можно, например: https://github.com/robinhowlett/everything-ssl (см. readme + src/test).
> В рамках задачи это не требуется, т.к. работа Spring Boot уже проверена до нас, см. https://github.com/spring-projects/spring-boot/tree/3.1.x/spring-boot-project/spring-boot/src/test/java/org/springframework/boot/web/server SslTests.java
2. Сервис защищен @PreAuthorize, а не @Secured и @PreFilter
> Плюс ещё есть @RolesAllowed. Но ни @RolesAllowed ни @Secured не позволят явным образом указать имя пользователя, только роль.
SpEL расширяет возможности и позволяет указать root явно, поэтому использование @PreAuthorize единственно правильно.
3. Добавлен PKCS12 keystore, команды для генерации ниже. Правда ощущение, что при запуске берется не из него
> Сертификат однозначно правильный и подхватывается именно он. По пути configured from нет такого файла (см. скрин). Похоже на баг в спринге, но подробнее сказать пока не могу.
> Здесь можно было бы сказать, что сертификат сгенерирован без Subject Alternative Name (IP, DNS), но во-первых, для localhost это избыточно, а во-вторых -- любой уважающий себя удостоверяющий центр даёт инструкцию по выпуску CSR, в которой это описано. Реализацию считаю корректной.
4. Для logout надо было использовать SecurityContextLogoutHandler
> К задаче есть два подхода: а) делать свои endpointы явно или б) целиком полагаться на фичи HttpSecurity. И тот и другой имеет право быть. SecurityContextLogoutHandler может дать преимущества в следующей задаче (а может и не дать). В общем, вопрос дискуссионный, т.к. оба варианта работают и явных недостатков первого подхода я не вижу.
5. Удалена аннотация @EnableWebSecurity, потому что работает и без нее (почему?)
> https://stackoverflow.com/questions/44671457
> If you are using Spring Boot, autoconfiguration classes (See https://github.com/spring-projects/spring-boot/tree/main/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/security) will autoconfigure security beans for you. There is no need for @EnableWebSecurity.

## Второе задание

1. OAUTH не нужен, так как его ему нужно внешнее апи + его главная фича - возможность авторизовываться в нескольких местах, мне не надо
> Совершенно верно. При рассмотрении OAuth важно понять идею, которая касается передачи всех clear-text credentials [RFC 6749 Section 3.2. Token Endpoint](https://www.rfc-editor.org/rfc/rfc6749#section-3.2) - сервер обязан использовать TLS.
2. Для AuthenticationEntryPoint выставлен HTTP код 404
> Хорошая идея, но в большинстве проектов не реализуется из-за требований DevOps к своему мониторингу.
> Если всё же возвращать 404 вместо 403, разбор попыток неавторизованного доступа усложнится, а чтобы не усложнять - для мониторинга нужно указывать конкретные имена endpointов, что в какой-то степени привязывает инфраструктуру к коду, но не является проблемой.
3. Ситуация "я могу 3 раза залогиниться, получить 3 разных JSESSIONID, разлогиниться из одного, и другие останутся рабочими"
> Если вкратце, вот поэтому: https://github.com/apache/tomcat/blob/main/java/org/apache/catalina/connector/Request.java#L2650
> Выход происходит из конкретной HTTP-сессии, JSESSIONID её уникально идентифицирует.
Это нормальное ожидаемое поведение для stateful аутентификации. Если требуется другое поведение, будут нюансы, см. [Properly Clearing an Authentication](https://docs.spring.io/spring-security/reference/servlet/authentication/session-management.html#properly-clearing-authentication) и далее по ссылкам.
4. Что такое возможность rememberMe
> Это возможность запоминать пользователя даже если JSESSIONID протухнет.
Подробности в [Remember-Me Authentication](https://docs.spring.io/spring-security/reference/servlet/authentication/rememberme.html).
5. Почему везде рекомендуют выключить csrf
> Не везде :) Spring рекомендует отключать на Remember-Me [When to use CSRF protection](https://docs.spring.io/spring-security/reference/features/exploits/csrf.html#csrf-when) и [No CSRF protection on remember-me authentication](https://github.com/spring-projects/spring-security/issues/3711), для остального REST API есть нюансы [Should I use CSRF protection on Rest API endpoints?](https://security.stackexchange.com/questions/166724/).
> В нашем конкретном случае CSRF можно смело отключить, т.к. браузерного взаимодействия (и вектора атаки) нет. К слову, при браузерном взаимодействии защита CSRF для POST, PUT, PATCH и DELETE используется парно с CORS, но это - отдельная большая тема в духе middle++, мы её не рассматриваем совсем.
6. Как exceptionHandling в конфиге соотносится с уже написанным мной ClockExceptionHandler
> Оба про исключения - в принципе, это всё, что у них общего. Суть:
> - ClockExceptionHandler обрабатывает ошибки всего, что вызывают методы REST контроллера. Он про то, как превращать ошибки прикладной логики в ответ REST API.
> - exceptionHandling - про HttpSecurity. Срабатывает "до" прикладной логики и отвечает за ошибки безопасности (до самого REST контроллера запрос может даже не дойти и срезаться на AuthorizationFilter).

## Первое задание

 1. Достаточно ли текущего времени сервера, можно ли ему доверять, или же необходимо реализовать синхронизацию с чем-то доверенным?
>можем; если предположить, что мы не доверяем времени сервера, в коде приложения разработчику придётся делать много дополнительных вещей, которые выходят за рамки чисто прикладного программирования. Поэтому считаем, что времени сервера можно доверять, а синхронизация системных часов по NTP — задача поддержки инфраструктуры, а не разработческая.\
Реализовать дополнительную синхронизацию имеет смысл, если мы занимаемся генерацией, подписанием или проверкой электронной цифровой подписи. Это стандарт, которому приложение обязано следовать, иначе оно не пройдёт сертификацию (Приказ ФСБ РФ от 4 декабря 2020 г. N 555). У нас в задаче такого нет.
 2. Зачем в контроллере объявление переменной var nowInTimezone и потом передача ее в конструктор? Можно же сразу return new CurrentTimeResponse(clockService.getNowInUtc())
>Сугубо дело вкуса, но если часто и помногу использовать вложенные конструкции, это не упрощает читаемость кода, а отладку — так и вообще усложняет, потому что для вычисления значения переменной нужно или становиться внутрь конструктора, что достаточно далеко от места вызова, или же вычислять значение лапками, что минус пять секунд и немного потеря контекста в голове. Если таких случаев по коду много, разница удобства очень заметна.
 3. Точно ли хороший стиль объявлять record прямо внутри Контроллера, а не в отдельном классе? Если да, то почему?
>Стиль неплохой, тем более если альтернативы только две "выносить" или "не выносить". Во-первых, record компактен, вынос в маленький файл не увеличивает удобство, поэтому не выносим. Во-вторых, прыжки по файлам лишний раз размывают внимание, а пользы не приносят, поэтому опять же не выносим. В-третьих, объект локально используется в пределах контроллера и за его границы не протекает. Поэтому — не выносим. Итого — совсем нет причин выносить в нашем конкретном случае.
 4. Про вот это:     // !!! Очень изящная реализация теста через ISO DateTimeFormatter, она позволяет не заморачиваться с хаками наподобие isAfter/isBefore для времени, но мысль не была доведена до конца :(  Как можно довести ее до конца? Насколько я понимаю, всякие наносекунды совпадать не будут при получении now() в сервисе и в тесте
>В предложенной реализации идея собственно и доведена до конца: мы знаем точный ответ сервиса и проверяем, что ответ контроллера в точности совпадает с тем, что вернул сервис, т.е.: а) контроллер не модифицирует данные сервиса и б) выполняет преобразование в корректный формат.
 5. Вы в тесте написали var tz = "Asia/Paris"; вместо String ianaTimezone = "Europe/Paris";. Это просто по привычке или же лучше писать var вместо явного объявления типа? Почему?
>Мне персонально нравится variable type inference, потому что код выглядит максимально компактно. Любая среда разработки в 2023 году уже подсвечивает тип — на случай, если он зачем-то понадобится. Лучше/хуже — субъективно, вопрос скорее проектных соглашений, если это правило явно закреплено, и личных духовных предпочтений, если не закреплено. Главное — соблюдать тотальное единообразие в пределах одного репозитория, т.е. либо всегда используем var (там, где выведение типа возможно) либо всегда не используем.
